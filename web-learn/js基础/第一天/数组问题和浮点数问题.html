<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title></title>
	<link rel="stylesheet" href="">
</head>
<body>
	<script>
		var arr7 = [0,1,2];
		    arr7[10] = 10;
    console.log(arr7.filter(function(x){return x === undefined})); //[]
    console.log(arr7[6]); //undefined
    console.log(arr7);//[0,1,2, empty x 7 ,10];

  		var two = 0.2;
     	var one = 0.1;
     	var eight = 0.8;
     	var six = 0.6;

     console.log([two -one == one,eight- six == two]);//[true, false]

//      两个浮点数相加或者相减，将会导致一定的正常的数据转换造成的精度丢失问题eight-six = 0.20000000000000007。

// JavaScript中的小数采用的是双精度(64位)表示的，由三部分组成：　符 + 阶码 + 尾数，在十进制中的 1/10，在十进制中可以简单写为 0.1 ，但在二进制中，他得写成：0.0001100110011001100110011001100110011001100110011001…..（后面全是 1001 循环）。因为浮点数只有52位有效数字，从第53位开始，就舍入了。这样就造成了“浮点数精度损失”问题。 

// 更严谨的做法是(eight-six ).toFiexd(1)或者用用Math.round方法回归整数运算。

</script>
</body>
</html>