<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title></title>
	<link rel="stylesheet" href="">
</head>
<body>
	<input id="input" type="text">
	<div>{{name}}</div>
</body>
<script>

	/*

	Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。

	1.只能对属性进行数据劫持，所以需要深度遍历整个对象
	2.对于数组不能监听到数据的变化
	*/
	function observe(obj){
		if(!obj || typeof obj !== 'object'){
			return
		}
		Object.keys(obj).forEach(key=>{
			defineReactive(obj,key,obj[key])
		})
	}
	// function defineReactive (obj,key,val) {
	// 	observe(val);
	// 	Object.defineProperty(obj, key, {
	// 		enumerable:true,
	// 		configurable:true,
	// 		get: function reactiveGetter(){
	// 			console.log('get value');
	// 			return val;
	// 		},
	// 		set: function reactiveSetter(newVal){
	// 			console.log('set value');
	// 			val = newVal;
	// 		}
	// 	})
	// }

	//通过Dep实现解耦
	class Dep{
		constructor(){
			this.subs = []
		}
		addSub(sub){
			this.subs.push(sub)
		}
		notify(){
			this.subs.forEach(sub=>{
				sub.update();
			})
		}
	}
	Dep.target = null;

	function update(value){
		document.getElementById('input').value = value;
		document.querySelector('div').innerText = value;
	}

	
	class Watcher{
		constructor(obj,key,cb){
		// 将 Dep.target 指向自己
	    // 然后触发属性的 getter 添加监听
	    // 最后将 Dep.target 置空
	    Dep.target = this;
	    this.cb = cb;
	    this.obj = obj;
	    this.key = key;
	    this.value = obj[key]
	    Dep.target = null;
	}

	update(){
		// 获得新值
		this.value = this.obj[this.key]
		// 调用 update 方法更新 Dom
		this.cb(this.value)
	}

	}
	var data = {name:'yck'}
	observe(data)
	// 模拟解析到 `{{name}}` 触发的操作
	new Watcher(data,'name',update)
	// update Dom innerText
	data.name = 'yyy';

	function defineReactive(obj,key,val){
		//递归子属性
		observe(val)
		let dp = new Dep();
		Object.defineProperty(obj, key, {
			enumerable:true,
			configurable:true,
			get: function reactiveGetter(){
				console.log('get value');
				if(Dep.target){
					dp.addSub(Dep.target)
				}
				return val;
			},
			set: function reactiveSetter(newVal){
				console.log('change value');
				val = newVal;
				dp.notify();
			}
		})
	}
	document.getElementById('input').addEventListener('keyup', function(e){
		data.name = e.target.value;
	})
</script>
</html>